[
    {
        "formal": "theorem measurable_cosh : Measurable cosh :=\n  continuous_cosh.measurable\n",
        "nl_statement": "Prove that the hyperbolic cosine function (cosh) is measurable.",
        "nl_proof": "1. We know that the hyperbolic cosine function (cosh) is continuous.\n2. Since continuous functions are measurable, we can conclude that the hyperbolic cosine function (cosh) is also measurable.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem measurable_cosh : Measurable cosh :=\n   continuous_cosh.measurable\n ",
        "source": "lean_basic",
        "uuid": "e27a984d-6548-21d0-7fcd-9eb1a7cad415",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "Bonnie makes the frame of a cube out of 12 pieces of wire that are each six inches long. Meanwhile Roark uses 1-inch-long pieces of wire to make a collection of unit cube frames that are not connected to each other. The total volume of Roark's cubes is the same as the volume of Bonnie's cube. What is the ratio of the total length of Bonnie's wire to the total length of Roark's wire? Express your answer as a common fraction. [asy]\nsize(50);\ndraw((0,0)--(4,0)--(4,4)--(0,4)--cycle);\ndraw((3,1)--(7,1)--(7,5)--(3,5)--cycle);\ndraw((0,0)--(3,1));\ndraw((4,0)--(7,1));\ndraw((4,4)--(7,5));\ndraw((0,4)--(3,5));\n[/asy]",
        "nl_proof": "The total length of Bonnie's wire is $12\\cdot6=72$ inches, while her total volume is $6^3=216$ cubic inches. Each of Roark's unit cubes has volume $1$ cubic inch, so he needs $216$ cubes.\n\nSince each cube has $12$ edges, each of Roark's cubes has $12\\cdot1=12$ inches of wire. So his $216$ cubes have a total of $216\\cdot12$ inches of wire.\n\nSo the desired fraction is $\\dfrac{72}{216\\cdot12}=\\dfrac{6}{216}=\\boxed{\\dfrac{1}{36}}$.\nThe answer is \\dfrac{1}{36}\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem roark_cube : (12 * 6 : ℚ) / (216 : ℚ) = 1 / 36 := by simp\n ",
        "source": "math",
        "uuid": "43b7a3a6-9a8d-ca03-580d-7b71d8f56413",
        "human_eval_inform": null,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem ofAdd_le {a b : α} : ofAdd a ≤ ofAdd b ↔ a ≤ b :=\n   Iff.rfl\n ",
        "nl_statement": "Prove that for any two elements 'a' and 'b', applying a strictly increasing function 'ofAdd' to them preserves the order, meaning if 'a' is less than or equal to 'b', then 'ofAdd(a)' is less than or equal to 'ofAdd(b)', and vice versa.",
        "nl_proof": "The statement holds directly by the definition of a strictly increasing function. If `ofAdd` is a strictly increasing function, then it's inherently defined to preserve the order of elements. This means that if 'a' is less than or equal to 'b', then 'ofAdd(a)' must be less than or equal to 'ofAdd(b)', and the other way around. Since this is a fundamental property of strictly increasing functions, the statement is immediately true.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem ofAdd_mono : Monotone (ofAdd : α → Additive α) :=\n   monotone_of_strictMono _\n ",
        "source": "lean_random",
        "uuid": "29a3b2e9-5d65-a441-d588-42dea2bc372f",
        "human_eval_inform": true,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y :=\n   (sq_lt.mp h).2\n ",
        "nl_statement": "Prove that for any non-negative numbers x and y, if the square of x is less than y, then x is less than the square root of y.",
        "nl_proof": "1. We are given that the square of x is less than y (x^2 < y).\n2. We can use a property about squares and square roots: if the square of one non-negative number is less than the square of another non-negative number, then the first number is also less than the second number.\n3. Applying this property to our case, since x^2 < y, we can conclude that x is less than the square root of y (x < sqrt(y)).\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem lt_sqrt_of_sq_lt {x y : ℝ} (h : x ^ 2 < y) : x < sqrt y :=\n   NNReal.coe_lt_coe.mp (sq_lt_sq_iff.1 h)\n ",
        "source": "lean_random",
        "uuid": "5715bd6f-a416-1293-c4c2-e2e3444ea7c8",
        "human_eval_inform": false,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem charmatrix_apply_eq : charmatrix M i i = (X : R[X]) - C (M i i) := by\n  simp only [charmatrix, RingHom.mapMatrix_apply, sub_apply, scalar_apply, map_apply,\n    diagonal_apply_eq]",
        "nl_statement": "Prove that the element at the \\(i\\)-th row and \\(i\\)-th column of the characteristic matrix of a matrix \\(M\\) is equal to \\(X\\) minus the image of the element at the \\(i\\)-th row and \\(i\\)-th column of \\(M\\) under the canonical ring homomorphism \\(C\\) from a ring \\(R\\) to the polynomial ring \\(R[X]\\).",
        "nl_proof": "1. We start by considering the element at the \\(i\\)-th row and \\(i\\)-th column of the characteristic matrix of \\(M\\), denoted as `charmatrix M i i`.\n2. By definition, the characteristic matrix is constructed by subtracting the image of each element of \\(M\\) under \\(C\\) from \\(X\\) along the diagonal and keeping other elements as they are.\n3. Therefore, the element at the \\(i\\)-th row and \\(i\\)-th column of the characteristic matrix is obtained by subtracting the image of the element at the \\(i\\)-th row and \\(i\\)-th column of \\(M\\) under \\(C\\) from \\(X\\).\n4. This can be formally written as \\(X\\) minus \\(C (M i i)\\), where \\(C (M i i)\\) represents the image of the \\(i\\)-th row and \\(i\\)-th column element of \\(M\\) under \\(C\\).\n5. Hence, we have shown that `charmatrix M i i = (X : R[X]) - C (M i i)`.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem charmatrix_self (i : n) : charmatrix M i i = (X : R[X]) - C (M i i) := by\n   rw [charmatrix, sub_self]\n ",
        "source": "lean_basic",
        "uuid": "23b8c1e9-3924-56de-3eb1-3b9046685257",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "Simplify: $|{-3^2+4}|$",
        "nl_proof": "We calculate as follows: \\[\n|{-3^2+4}|=|{-9+4}|=|{-5}|=\\boxed{5}.\\] Note that $-3^2=-9$ because our conventions for carrying out operations dictate that exponentiation should be done before negation. Hence $-3^2$ means $-(3^2)$ rather than $(-3)^2$.\nThe answer is 5\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem abs_neg_cubed_add_four : |-3 ^ 2 + 4| = 5 := by simp\n ",
        "source": "math",
        "uuid": "ec1b8ca1-f91e-1d4c-1ff4-9b7889463e85",
        "human_eval_inform": null,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem comap_map_le : (m.map f).comap f ≤ m :=\n  (gc_comap_map f).l_u_le _\n",
        "nl_statement": "Suppose we have a function 'f' and a mapping 'm' (you can imagine a mapping as a way to associate elements from one set to another).  If we first apply 'f' to the input of 'm', then use 'm', and finally consider all possible inputs to 'f' that lead to the same output, this resulting mapping will be \"smaller\" than or equal to our original mapping 'm'.",
        "nl_proof": "1. Start with our mapping 'm'.\n2. We first apply 'f' to the outputs of 'm', resulting in a new mapping (let's call it 'm_f').\n3. Now, consider all possible inputs to 'f' that, when used in 'm_f', produce the same output. This gives us another mapping, which is `(m.map f).comap f`.\n4. The core idea is that by considering all such inputs to 'f', we are essentially \"undoing\" the effect of 'f' to some extent.  \n5. The lemma `gc_comap_map f` likely formalizes this \"undoing\" and provides a general relationship between `comap` and `map` with 'f'.\n6. Using a specific part of this lemma (`l_u_le _`), we can conclude that our final mapping `(m.map f).comap f` is \"smaller\" than or equal to our original mapping 'm'. This means that any input-output pair in `(m.map f).comap f` must also be present in 'm'.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem comap_map_le : (m.map f).comap f ≤ m :=\n   (gc_comap_map f).l_u_le _\n ",
        "source": "lean_basic",
        "uuid": "366eb16f-508e-bad7-b7c9-3acfe059a0ee",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem union_union_distrib_left (s t u : Finset α) : s ∪ (t ∪ u) = s ∪ t ∪ (s ∪ u) :=\n   sup_sup_distrib_left _ _ _\n ",
        "nl_statement": "Prove that for any three finite sets \\( s₁ \\), \\( s₂ \\), and \\( s₃ \\), if \\( s₁ \\) is a superset of \\( s₂ \\) and \\( s₂ \\) is a superset of \\( s₃ \\), then \\( s₁ \\) is a superset of \\( s₃ \\).",
        "nl_proof": "1. We are given that \\( s₁ \\) is a superset of \\( s₂ \\). This means that every element in \\( s₂ \\) is also an element of \\( s₁ \\).\n2. We are also given that \\( s₂ \\) is a superset of \\( s₃ \\). This means that every element in \\( s₃ \\) is also an element of \\( s₂ \\).\n3. Now, consider any element in \\( s₃ \\). Since \\( s₂ \\) is a superset of \\( s₃ \\), this element must also be in \\( s₂ \\).\n4. Furthermore, since \\( s₁ \\) is a superset of \\( s₂ \\), and the element is in \\( s₂ \\), it must also be in \\( s₁ \\).\n5. Therefore, any element in \\( s₃ \\) is also in \\( s₁ \\).\n6. This proves that  \\( s₁ \\) is a superset of \\( s₃ \\).\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem Superset.trans {s₁ s₂ s₃ : Finset α} (h₁ : s₁ ⊆ s₂) (h₂ : s₂ ⊆ s₃) : s₁ ⊆ s₃ :=\n   h₁.mono h₂\n ",
        "source": "lean_random",
        "uuid": "fc377a4c-4a15-544d-c5e7-ce8a3a578a8e",
        "human_eval_inform": false,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem monovary_self (f : ι → α) : Monovary f f := fun _ _ => le_of_lt\n ",
        "nl_statement": "Prove that any function `f` from a set `ι` to a set `α` is \"monovariant\" with itself. In simpler terms, if we apply `f` to two arguments and the first argument is less than the second, then applying `f` won't change that order.",
        "nl_proof": "1. Let's imagine we have two elements from the set `ι`. We'll call them `x` and `y`.\n2. We are given that `x < y`. This means `x` comes before `y` in the order of elements within the set `ι`.\n3. Our goal is to prove that applying the function `f` doesn't change this order.  In other words, we need to show that `f(x) ≤ f(y)`.\n4. Since `x < y`, we can directly apply the lemma `le_of_lt` to conclude that `x ≤ y`.\n5. Since `f(x)` and `f(y)` are just the results of applying the function `f` to `x` and `y` respectively, and we know `x ≤ y`, we can conclude that `f(x) ≤ f(y)`.  This is because applying the same function `f` doesn't change the relative order of the results.\n6. Therefore, we have shown that if `x < y`, then `f(x) ≤ f(y)`. This holds true for any arbitrary elements `x` and `y` from the set `ι`.\n\nTherefore, the function `f` is \"monovariant\" with itself, meaning it preserves the order of elements when applied to its inputs.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem monovary_self : Monovary f f := fun _ _ => le_of_lt\n ",
        "source": "lean_random",
        "uuid": "ab9099a4-35a2-40ae-5af3-05535ec42e08",
        "human_eval_inform": true,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem preimage_add_const_Ioc : (fun x => x + a) ⁻¹' Ioc b c = Ioc (b - a) (c - a) := by\n   simp [← Ioi_inter_Iic]\n ",
        "nl_statement": "Prove that the preimage of the open interval (b, c) under the function that adds a constant 'a' to a number is equal to the open interval (b - a, c - a).",
        "nl_proof": "1. We need to prove that a number 'x' lies in the preimage of the interval (b, c) under the function 'x + a' if and only if it lies in the interval (b - a, c - a).\n2. A number 'x' belongs to the preimage of (b, c) under the function 'x + a' if and only if 'x + a' belongs to the interval (b, c).\n3. This means 'b < x + a < c'.\n4. Subtracting 'a' from all parts of the inequality, we get 'b - a < x < c - a'.\n5. This implies that 'x' belongs to the open interval (b - a, c - a).\n6. Conversely, if 'x' belongs to the interval (b - a, c - a), then 'b - a < x < c - a'.\n7. Adding 'a' to all parts of the inequality, we get 'b < x + a < c', which means 'x + a' belongs to the interval (b, c).\n8. Therefore, the preimage of the open interval (b, c) under the function 'x + a' is equal to the open interval (b - a, c - a).\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem preimage_add_const_Ioo : (fun x => x + a) ⁻¹' Ioo b c = Ioo (b - a) (c - a) := by\n   simp [← Ici_inter_Iio, inter_comm, add_comm]\n ",
        "source": "lean_random",
        "uuid": "3eabedcb-baa8-0dd4-88bd-64072bcfbe01",
        "human_eval_inform": false,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "If $a$ is a constant such that $9x^2 + 24x + a$ is the square of a binomial, then what is $a$?",
        "nl_proof": "If $9x^2 +24x + a$ is the square of a binomial, then the binomial has the form $3x +b$ for some number $b$, because $(3x)^2 = 9x^2$.  So, we compare $(3x+b)^2$ to $9x^2 + 24x + a$. Expanding $(3x+b)^2$ gives \\[(3x+b)^2 = (3x)^2 + 2(3x)(b) + b^2 = 9x^2 + 6bx + b^2.\\]Equating the linear term of this to the linear term of $9x^2+24x+a$, we have $6bx=24x$, so $b=4$.  Equating the constant term of $9x^2 + 6bx + b^2$ to that of $9x^2 + 24x+a$ gives us $a=b^2 = \\boxed{16}$.\nThe answer is 16\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem isSquare_eq_16 : IsSquare a ↔ a = 16 := by\n   rw [isSquare_iff_exists_linear_eq_sq, ← sq_linear_eq_sq_iff']\n   set_option tactic.skipAssignedInstances false in norm_num\n   rw [mul_comm, mul_assoc]\n   exact mul_right_cancel₀ (mul_ne_zero 3 3)\n ",
        "source": "math",
        "uuid": "1a2a73ed-562b-0f79-c374-59eef50bea63",
        "human_eval_inform": null,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "Compute $\\begin{pmatrix} 2 & 3 \\\\ 7 & -1 \\end{pmatrix} \\begin{pmatrix} 1 & -5 \\\\ 0 & 4 \\end{pmatrix}.$",
        "nl_proof": "We have that\n\\[\\begin{pmatrix} 2 & 3 \\\\ 7 & -1 \\end{pmatrix} \\begin{pmatrix} 1 & -5 \\\\ 0 & 4 \\end{pmatrix} = \\begin{pmatrix} (2)(1) + (3)(0) & (2)(-5) + (3)(4) \\\\ (7)(1) + (-1)(0) & (7)(-5) + (-1)(4) \\end{pmatrix} = \\boxed{\\begin{pmatrix} 2 & 2 \\\\ 7 & -39 \\end{pmatrix}}.\\]\nThe answer is \\begin{pmatrix} 2 & 2 \\\\ 7 & -39 \\end{pmatrix}\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem two_three_seven_neg_one_one_neg_five_zero_four : (2 : ℤ) * (1 : ℤ) + 3 * 0 = 2 :=\n   rfl\n ",
        "source": "math",
        "uuid": "405cacec-8774-09a9-77d2-1e02ff01cf99",
        "human_eval_inform": null,
        "human_eval_autoform": false
    },
    {
        "formal": null,
        "nl_statement": "Given that $2^x+ 2^x+ 2^x+ 2^x= 128$, what is the value of $(x + 1)(x - 1)$?",
        "nl_proof": "First, we simplify the left side, and we have \\[2^x+2^x+2^x+2^x = 4\\cdot 2^x = 2^2\\cdot 2^x = 2^{x+2}.\\]Noting that $128 = 2^7$, our equation now is $2^{x+2} = 2^7$, so $x+2 = 7$.  Therefore, $x=5$, and $(x+1)(x-1) = (6)(4) = \\boxed{24}$.\nThe answer is 24\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem eq_24 : (x + 1) * (x - 1) = 24 := by\n   have h1 : 2 ^ x + 2 ^ x + 2 ^ x + 2 ^ x = 128 := by rw [add_add_add_comm]; simp\n   rw [h1, pow_add, pow_one, pow_neg, pow_add, ← two_mul, pow_add, pow_add, pow_one,\n     pow_neg, pow_add, pow_add, pow_one, pow_neg, pow_add, pow_add, pow_one]\n   have h2 : 2 ^ 5 + 2 ^ 5 + 2 ^ 5 + 2 ^ 5 = 128 := by rw [h1, add_add_add_comm, ← ‹2 ^ (x + 2) = 128›,\n     mul_comm, mul_assoc, mul_right_comm]\n   rw [← h2, mul_comm]\n ",
        "source": "math",
        "uuid": "371ecd7b-27cd-8130-4722-9389571aa876",
        "human_eval_inform": null,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem toOuterMeasure_injective : (toOuterMeasure : PMF α → OuterMeasure α).Injective :=\n  fun p q h => PMF.ext fun x => (p.toOuterMeasure_apply_singleton x).symm.trans\n    ((congr_fun (congr_arg _ h) _).trans <| q.toOuterMeasure_apply_singleton x)\n",
        "nl_statement": "Prove that the function `toOuterMeasure`, which converts a probability mass function (PMF) to an outer measure, is injective. In other words, prove that if two PMFs `p` and `q` are mapped to the same outer measure, then `p` and `q` must be the same PMF.",
        "nl_proof": "1. Assume we have two PMFs, `p` and `q`, such that `toOuterMeasure p = toOuterMeasure q` (i.e., they map to the same outer measure).\n2. To prove `p = q`, we need to show that they assign the same probability to every element `x`.\n3. Consider an arbitrary element `x`. We know that `p.toOuterMeasure_apply_singleton x` represents the probability assigned to `x` by `p`, and similarly for `q`.\n4. From our initial assumption (`toOuterMeasure p = toOuterMeasure q`) and applying both outer measures to the singleton set `{x}`, we get: `(toOuterMeasure p) {x} = (toOuterMeasure q) {x}`.\n5. Using the lemma `toOuterMeasure_apply_singleton x`, we can rewrite this as: `p.toOuterMeasure_apply_singleton x = q.toOuterMeasure_apply_singleton x`.\n6. This shows that `p` and `q` assign the same probability to an arbitrary element `x`.\n7. Since `x` was arbitrary, we can conclude that `p` and `q` assign the same probability to all elements.\n8. Therefore, using the lemma `PMF.ext`, we can conclude that `p = q`.\n9. This proves that the `toOuterMeasure` function is injective, meaning that distinct PMFs always map to distinct outer measures.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem toOuterMeasure_injective : Function.Injective (toOuterMeasure : PMF α → OuterMeasure α) :=\n   fun p q h => PMF.ext fun x => by rw [← toOuterMeasure_apply_singleton x, h, toOuterMeasure_apply_singleton x]\n ",
        "source": "lean_basic",
        "uuid": "b02b61c4-a3d7-0628-ece6-6fa2fd5166e6",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "Positive integers $a$, $b$, and $c$ are chosen so that $a<b<c$, and the system of equations \\[\n2x + y = 2003\\quad\\text{and}\\quad y = |x-a| + |x-b| + |x-c|\n\\]has exactly one solution. What is the minimum value of $c$?",
        "nl_proof": "Since the system has exactly one solution, the graphs of the two equations must intersect at exactly one point. If $x<a$, the equation $y = |x-a| + |x-b| + |x-c|$ is equivalent to $y =-3x + (a+b+c)$. By similar calculations we obtain\n\n\\[\ny =\n\\begin{cases}\n-3x + (a+b+c), &\\text{if }x<a\\\\\n-x + (-a+b+c), &\\text{if }a\\le x<b\\\\\nx + (-a-b+c), &\\text{if }b\\le x<c\\\\\n3x + (-a-b-c), &\\text{if }c\\le x.\n\\end{cases}\n\\]Thus the graph consists of four lines with slopes $-3$, $-1$, 1, and 3, and it has corners at $(a, b+c-2a)$, $(b, c-a)$, and $(c,\n2c-a-b)$.\n\nOn the other hand, the graph of $2x+y = 2003$ is a line whose slope is $-2$. If the graphs intersect at exactly one point, that point must be $(a, b+c-2a).$ Therefore\n\n$ 2003 = 2a + (b+c-2a) = b+c. $\n\nSince $b<c$, the minimum value of $c$ is $\\boxed{1002}$.\nThe answer is 1002\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem eq_1100 : c = 1002 := by\n   rw [min_eq_iff_eq_and_le]\n   rw [le_eq_iff_eq_le]\n   rw [← sub_add, ← sub_add, add_assoc, sub_add_cancel, ← sub_self]\n   exact (sub_nonneg (a + b) zero_le_two).antisymm (add_nonneg b (2 * 1001))\n ",
        "source": "math",
        "uuid": "6c307511-b2b9-437a-28df-6ec4ce4a2bbd",
        "human_eval_inform": null,
        "human_eval_autoform": false
    }
]