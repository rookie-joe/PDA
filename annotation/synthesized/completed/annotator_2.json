[
    {
        "formal": "theorem measurable_exp : Measurable exp :=\n  continuous_exp.measurable\n",
        "nl_statement": "Prove that the exponential function is measurable.",
        "nl_proof": "We know that the exponential function (`exp`) is a continuous function. Additionally, a fundamental property of continuous functions is that they are always measurable. Therefore, we can directly conclude that the exponential function (`exp`) is measurable.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem measurable_exp : Measurable exp :=\n   continuous_exp.measurable\n ",
        "source": "lean_basic",
        "uuid": "beb79919-3f22-faf8-23be-d01d43cf2fde",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem toOuterMeasure_apply_eq_one_iff : p.toOuterMeasure s = 1 ↔ p.support ⊆ s := by\n  refine' (p.toOuterMeasure_apply s).symm ▸ ⟨fun h a hap => _, fun h => _⟩\n  · refine' by_contra fun hs => ne_of_lt _ (h.trans p.tsum_coe.symm)\n    have hs' : s.indicator p a = 0 := Set.indicator_apply_eq_zero.2 fun hs' => False.elim <| hs hs'\n    have hsa : s.indicator p a < p a := hs'.symm ▸ (p.apply_pos_iff a).2 hap\n    exact ENNReal.tsum_lt_tsum (p.tsum_coe_indicator_ne_top s)\n      (fun x => Set.indicator_apply_le fun _ => le_rfl) hsa\n  · suffices ∀ (x) (_ : x ∉ s), p x = 0 from\n      _root_.trans (tsum_congr\n        fun a => (Set.indicator_apply s p a).trans (ite_eq_left_iff.2 <| symm ∘ this a)) p.tsum_coe\n    exact fun a ha => (p.apply_eq_zero_iff a).2 <| Set.not_mem_subset h ha\n",
        "nl_statement": "Let \\(p\\) be a function that assigns a non-negative \"weight\" to each element in a set. The \"outer measure\" of a subset \\(s\\) is the total weight of elements in \\(s\\). The \"support\" of \\(p\\) is the set of all elements with non-zero weight. Prove that the outer measure of \\(s\\) equals 1 if and only if the support of \\(p\\) is contained within \\(s\\).",
        "nl_proof": "We need to prove both directions of the \"if and only if\" statement.\n\n**Direction 1 (→): If the outer measure of \\(s\\) is 1, then the support of \\(p\\) is contained within \\(s\\).**\n\n1. **Assumption**: Let's assume the outer measure of \\(s\\) with respect to \\(p\\) is 1.\n\n2. **Proof by Contradiction**: Assume, for contradiction, that the support of \\(p\\) is not a subset of \\(s\\). This means there exists an element, let's call it 'a', which belongs to the support of \\(p\\) but not to \\(s\\).\n\n3. **Element 'a' and its weight**: Since 'a' is in the support of \\(p\\), its weight, \\(p(a)\\), is strictly greater than 0.\n\n4. **Impact on outer measure**: Because 'a' is not in \\(s\\) but has a positive weight, the outer measure of \\(s\\) would be strictly less than 1 (as we're not including the weight of 'a' in the sum).\n\n5. **Contradiction**: This contradicts our initial assumption that the outer measure of \\(s\\) is 1. Therefore, our assumption that the support of \\(p\\) is not a subset of \\(s\\) must be false.\n\n**Direction 2 (←): If the support of \\(p\\) is contained within \\(s\\), then the outer measure of \\(s\\) is 1.**\n\n1. **Assumption**: Let's assume the support of \\(p\\) is a subset of \\(s\\). \n\n2. **Total Weight**: This means all elements with non-zero weight under \\(p\\) are within \\(s\\). Since the total weight assigned by \\(p\\) across all elements is 1, and all elements with non-zero weight are in \\(s\\), the outer measure of \\(s\\) (which sums the weights of elements in \\(s\\)) must be 1.\n\n**Conclusion**: Since we have proven both directions, we have shown that the outer measure of a set \\(s\\) with respect to a weight function \\(p\\) is equal to 1 if and only if the support of \\(p\\) is contained within \\(s\\).\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem toOuterMeasure_apply_eq_one_iff : p.toOuterMeasure s = 1 ↔ p.support ⊆ s := by\n   refine' ⟨fun h => _, fun h => _⟩\n   · contrapose! h\n     rw [← h]\n     refine' ⟨_, fun a ha => _⟩\n     · rw [not_mem_support_iff] at ha\n       exact zero_lt_one (p a)\n     · rw [← ha, p.apply_zero]\n       exact csInf_lt_one (h.mono (mem_support_iff.2 ha))\n   · exact toOuterMeasure_apply_of_support_subset_of_sum_eq_one s h\n ",
        "source": "lean_basic",
        "uuid": "ce177b4e-0837-b8a3-d261-a7ab3aa2e4f9",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem ne_zero_of_b_ne_zero (hb : P.b ≠ 0) : P.toPoly ≠ 0 :=\n   (or_imp.mp (or_imp.mp ne_zero).2).1 hb\n ",
        "nl_statement": "Let's say we have a way to represent a mathematical expression called \"P\". This expression \"P\" has a specific term we call \"b\". We also have a way to transform this expression \"P\" into a polynomial, and we call this transformed polynomial \"P.toPoly\".  Prove that if the term \"b\" in our expression \"P\" is not equal to zero, then the polynomial representation of \"P\", denoted as \"P.toPoly\", is also not equal to zero.",
        "nl_proof": "1. We begin with the given fact: the term \"b\" in our mathematical expression \"P\" is not equal to zero.\n2. We know there's a rule (from the `ne_zero` theorem/lemma) that helps us figure out when a polynomial is not equal to zero. This rule likely involves checking if any of the polynomial's coefficients are non-zero.\n3. We carefully examine this rule, breaking it down using logical steps (`or_imp.mp`).\n4. Due to the way our expression \"P\" is structured and the fact that \"b\" is not zero, we can apply this rule to the polynomial representation of \"P\", which is \"P.toPoly\". \n5. By applying this rule, we demonstrate that \"P.toPoly\" must also have at least one non-zero coefficient.\n6. Therefore, because it has a non-zero coefficient, the entire polynomial \"P.toPoly\" cannot be equal to zero.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem toPoly_ne_zero (hb : b ≠ 0) : P.toPoly ≠ 0 :=\n   (ne_zero.mp (or_imp.mp hb)).1\n ",
        "source": "lean_random",
        "uuid": "7412b293-4729-4739-614f-f3d719db3ad0",
        "human_eval_inform": false,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support := by\n   rw [neLocus_comm, neLocus_self_add_right]\n ",
        "nl_statement": "For any two functions \\( f \\) and \\( g \\), the set of points where \\( f + g \\) differs from \\( f \\) is precisely the set of points where \\( g \\) is nonzero.",
        "nl_proof": "1. Start with the set of points where \\( f + g \\) is different from \\( f \\):  `neLocus (f + g) f`.\n2. Using `neLocus_comm`, we can swap the order of functions without changing the meaning: `neLocus f (f + g)`.\n3. Now, we can apply `neLocus_self_add_right` (with \\( h \\) as \\( f \\) in the lemma). This tells us that the set of points where \\( f + g \\) differs from \\( f \\) is the same as the support of \\( g \\): `g.support`.\n4. Therefore, we have proved that `neLocus (f + g) f = g.support`.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem neLocus_add_self_right : neLocus (f + g) f = g.support := by\n   rw [neLocus_comm, neLocus_self_add_right]\n ",
        "source": "lean_random",
        "uuid": "81f631d4-a392-31a7-d777-a4774c66e0a8",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem charpoly_monic : f.charpoly.Monic :=\n  Matrix.charpoly_monic _\n",
        "nl_statement": "Prove that the characteristic polynomial of any square matrix is monic.",
        "nl_proof": "We want to show that the characteristic polynomial of any square matrix is monic. A fundamental property of characteristic polynomials, proven in matrix theory, is that they are always monic. Therefore, the characteristic polynomial of the given square matrix `f` is also monic.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem monic : Monic f.charpoly :=\n   @Polynomial.monic _ _ _ _ _ _ f.charpoly\n ",
        "source": "lean_basic",
        "uuid": "0e51f30d-c6a7-ee39-c4b0-32ccd7c524a5",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "The equation $\\sin^2 x + \\sin^2 2x + \\sin^2 3x + \\sin^2 4x = 2$ can be reduced to the equivalent equation\n\\[\\cos ax \\cos bx \\cos cx = 0,\\]for some positive integers $a,$ $b,$ and $c.$  Find $a + b + c.$",
        "nl_proof": "From the double angle formula,\n\\[\\frac{1 - \\cos 2x}{2} + \\frac{1 - \\cos 4x}{2} + \\frac{1 - \\cos 6x}{2} + \\frac{1 - \\cos 8x}{2} = 2,\\]so $\\cos 2x + \\cos 4x + \\cos 6x + \\cos 8x = 0.$  Then by sum-to-product,\n\\[\\cos 2x + \\cos 8x = 2 \\cos 5x \\cos 3x\\]and\n\\[\\cos 4x + \\cos 6x = 2 \\cos 5x \\cos x,\\]so\n\\[2 \\cos 5x \\cos 3x + 2 \\cos 5x \\cos x= 0,\\]or $\\cos 5x (\\cos x + \\cos 3x) = 0.$\n\nAgain by sum-to-product, $\\cos x + \\cos 3x = 2 \\cos 2x \\cos x,$ so this reduces to\n\\[\\cos x \\cos 2x \\cos 5x = 0.\\]Thus, $a + b + c = 1 + 2 + 5 = \\boxed{8}.$\nThe answer is 8\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem add_coe_sin_pow_two : (1 : ℤ) + (2 : ℤ) + (3 : ℤ) + (4 : ℤ) = 8 := by\n   simpa using @sin_pow_two_add_cos_mul_cos 2 4\n ",
        "source": "math",
        "uuid": "bf3c4c06-4343-08bc-89fa-6a688fb5d27b",
        "human_eval_inform": null,
        "human_eval_autoform": false
    },
    {
        "formal": null,
        "nl_statement": "Compute $(-64)\\div (-32)$.",
        "nl_proof": "When $y$ is nonzero, we have $(-x)\\div (-y) = x\\div y$, so \\[(-64)\\div (-32) = 64\\div 32= \\boxed{2}.\\]\nThe answer is 2\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem neg_div_neg : (-64) / (-32) = 2 := by simp\n ",
        "source": "math",
        "uuid": "4b0dbb41-8d52-88f1-142c-3fe860e7a113",
        "human_eval_inform": null,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem toOuterMeasure_caratheodory : p.toOuterMeasure.caratheodory = ⊤ := by\n  refine' eq_top_iff.2 <| le_trans (le_sInf fun x hx => _) (le_sum_caratheodory _)\n  have ⟨y, hy⟩ := hx\n  exact\n    ((le_of_eq (dirac_caratheodory y).symm).trans (le_smul_caratheodory _ _)).trans (le_of_eq hy)\n",
        "nl_statement": "Prove that the Carathéodory outer measure induced by the outer measure generated by a premeasure 'p' is equal to the top element of the lattice, meaning it assigns infinite measure to all sets.",
        "nl_proof": "1. **Goal:** We aim to show that the Carathéodory outer measure derived from 'p' is the top element, meaning it's greater than or equal to every other outer measure.\n2. **Strategy:** To prove this, we'll demonstrate that for any arbitrary set, the Carathéodory outer measure assigns a value greater than or equal to what any other outer measure would assign.\n3. **Dirac Measures:** We utilize Dirac measures, which assign a value of 1 to sets containing a specific point and 0 otherwise. For any point 'y' in our set, we consider the Dirac measure centered at 'y'.\n4. **Carathéodory Property:** Due to the Carathéodory construction, we know that our outer measure of any set is less than or equal to the sum of its values on two sets that \"split\" the original set in a specific way.\n5. **Combining Inequalities:** We combine the fact that the Dirac measure is less than or equal to the Carathéodory outer measure (by definition of Dirac) and the Carathéodory property. This allows us to relate the Carathéodory outer measure to the value assigned by any other outer measure.\n6. **Taking the Supremum:** Since this holds for any point 'y', we can take the supremum over all 'y' and still maintain the inequality. This establishes that the Carathéodory outer measure is greater than or equal to the other outer measure for any arbitrary set.\n7. **Conclusion:** As this holds for any arbitrary outer measure, we conclude that the Carathéodory outer measure is the top element, assigning infinite measure to every set.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem toOuterMeasure_caratheodory : p.toOuterMeasure.caratheodory = ⊤ := by\n   refine' eq_top_iff.2 fun y => le_trans (dirac y).le (le_sum_of_le_left _ _ _)\n   exact (le_sum_left_iff _ _).2 fun x hx => le_sum_left_iff.2 fun z hz => le_sum_left_iff.2 fun w hw =>\n     le_sum_left_iff.2 fun u hu => le_sum_left_iff.2 fun v hv => le_sum_left_iff.2 fun t ht =>\n       le_sum_left_iff.2 fun x' hx' => le_sum_left_iff.2 fun y' hy' => le_sum_left_iff.2 fun z' hz' =>\n         le_sum_left_iff.2 fun w' hw' => le_sum_left_iff.2 fun u' hu' => _\n   · exact le_caratheodory ⟨x, hx, z, hz, w, hw, u, hu, v, hv, t, ht, x', hx', y', hy', z', hz', w', hw',\n       u', hu', t, ht, hv, hx'⟩\n   · rw [caratheodory_apply, sum_empty]\n ",
        "source": "lean_basic",
        "uuid": "972a8469-1641-9f82-8b9d-2434e465e150",
        "human_eval_inform": null,
        "human_eval_autoform": null
    },
    {
        "formal": "theorem ofReal_nsmul {x : ℝ} {n : ℕ} : ENNReal.ofReal (n • x) = n • ENNReal.ofReal x := by\n   simp only [nsmul_eq_mul, ← ofReal_coe_nat n, ← ofReal_mul n.cast_nonneg]\n ",
        "nl_statement": "Prove that for any real number \\( x \\) and any natural number \\( n \\),  the sine of the difference between \\( x \\) and \\( n \\) times two pi is equal to the sine of \\( x \\).",
        "nl_proof": "1. We know that the sine function has a period of \\( 2\\pi \\). This means that for any real number \\( x \\),  \\( \\sin(x + 2\\pi) = \\sin(x) \\).\n2. We can extend this to any integer multiple of \\( 2\\pi \\). For any natural number \\( n \\), shifting the input by \\( n \\) times \\( 2\\pi \\) still results in the same sine value: \\( \\sin(x + n * 2\\pi) = \\sin(x) \\).\n3. Now, consider subtracting \\( n * 2\\pi \\) from \\( x \\). Since adding and subtracting are inverse operations, this is equivalent to shifting in the opposite direction by the same amount.\n4. Due to the periodicity of the sine function, shifting in either direction by a multiple of the period results in the same value. Therefore: \\( \\sin(x - n * 2\\pi) = \\sin(x) \\).\nThis proves that for any real number \\( x \\) and natural number \\( n \\), the sine of \\( x \\) minus \\( n \\) times two pi is equal to the sine of \\( x \\).\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem sin_sub_nat_mul_two_pi (x : ℝ) (n : ℕ) : sin (x - n * (2 * π)) = sin x :=\n   sin_periodic.sub_nat_mul_eq n\n ",
        "source": "lean_random",
        "uuid": "5fb8d16c-2720-797d-32eb-d6899be578c7",
        "human_eval_inform": false,
        "human_eval_autoform": false
    },
    {
        "formal": null,
        "nl_statement": "Given that $2^x+ 2^x+ 2^x+ 2^x= 128$, what is the value of $(x + 1)(x - 1)$?",
        "nl_proof": "First, we simplify the left side, and we have \\[2^x+2^x+2^x+2^x = 4\\cdot 2^x = 2^2\\cdot 2^x = 2^{x+2}.\\]Noting that $128 = 2^7$, our equation now is $2^{x+2} = 2^7$, so $x+2 = 7$.  Therefore, $x=5$, and $(x+1)(x-1) = (6)(4) = \\boxed{24}$.\nThe answer is 24\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem eq_24 : (x + 1) * (x - 1) = 24 := by\n   have h1 : 2 ^ x + 2 ^ x + 2 ^ x + 2 ^ x = 128 := by rw [add_add_add_comm]; simp\n   rw [h1, pow_add, pow_one, pow_neg, pow_add, ← two_mul, pow_add, pow_add, pow_one,\n     pow_neg, pow_add, pow_add, pow_one, pow_neg, pow_add, pow_add, pow_one]\n   have h2 : 2 ^ 5 + 2 ^ 5 + 2 ^ 5 + 2 ^ 5 = 128 := by rw [h1, add_add_add_comm, ← ‹2 ^ (x + 2) = 128›,\n     mul_comm, mul_assoc, mul_right_comm]\n   rw [← h2, mul_comm]\n ",
        "source": "math",
        "uuid": "371ecd7b-27cd-8130-4722-9389571aa876",
        "human_eval_inform": null,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem measure_ball_pos (x : X) {r : ℝ} (hr : 0 < r) : 0 < μ (ball x r) :=\n   isOpen_ball.measure_pos μ (nonempty_ball.2 hr)\n ",
        "nl_statement": "Prove that the measure of an open ball in a metric space is always greater than 0, given that the radius of the ball is greater than 0.",
        "nl_proof": "1. We are given an open ball centered at point `x` with radius `r`, where `r` is a positive real number.\n2. Since `r` is positive, the open ball is not empty; it contains points of our metric space.\n3. Open balls, by their definition, are considered \"open\" sets in the metric space.\n4. An important property of measures is that they assign a size greater than 0 to any open set that's not empty.\n5. Therefore, the measure of our open ball, which we know is both not empty and an open set, must be greater than 0.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem measure_ball_pos (hr : 0 < r) : 0 < μ (Metric.ball x r) :=\n   measure_open_pos _ <| Nonempty.intro <| Metric.ball_nonempty hr\n ",
        "source": "lean_random",
        "uuid": "a9488d99-0bbb-2599-11ce-5dd2b45ed1f0",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem zero [Nontrivial M₀] : IsPrimitiveRoot (0 : M₀) 0 :=\n   ⟨pow_zero 0, fun l hl => by\n     simpa [zero_pow_eq, show ∀ p, ¬p → False ↔ p from @Classical.not_not] using hl⟩\n ",
        "nl_statement": "Prove that in any nontrivial multiplicative group `M₀`, the element `0` is a primitive root of unity of order `0`.",
        "nl_proof": "We need to demonstrate two things for `0` to be a primitive `0`th root of unity in `M₀`:\n\n1. **`0^0 = 1`**: This is generally true for elements in a group (any element raised to the power `0` equals the identity element).\n2. **No smaller `k` exists**: We need to show there is no positive integer `k < 0` such that `0^k = 1`. Since there are no positive integers smaller than `0`, this condition is automatically satisfied.\n\nTherefore, in a nontrivial multiplicative group `M₀`, the element `0` is a primitive root of unity of order `0`.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem isPrimitiveRoot_zero [Nontrivial M₀] : IsPrimitiveRoot (0 : M₀) 0 :=\n   ⟨pow_zero (0 : M₀), fun k hk =>\n     not_lt_of_ge (Nat.cast_nonneg _) (Nat.cast_lt.not.1 <| hk.trans_le <| Nat.zero_le _)⟩\n ",
        "source": "lean_random",
        "uuid": "ddd1dfb2-3b98-2ef8-daf6-1a26146d3f31",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "A cylindrical water tank is $\\frac{1}{5}$ full. If three liters were added, the tank would be $\\frac{1}{4}$ full. How many liters does the tank hold when it is full?",
        "nl_proof": "Let the number of liters of water in the tank originally be $w$, and let the number of liters of water the tank can hold when it is full be $c$. Originally, we have the equation $\\frac{w}{c}=\\frac{1}{5}$. Cross multiplying, we have $c = 5w$, or $w=\\frac{c}{5}$. After three liters of water are added, we have the equation $\\frac{w+3}{c} = \\frac{1}{4}$. Cross multiplying, we have $c=4w+12$. Substituting the previous expression for $w$ into this last equation to eliminate $w$, we get $c=4(\\frac{c}{5})+12$, or $c=60$. Thus, the number of liters of water the tank can hold is $\\boxed{60}$.\nThe answer is 60\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem cylinder_add_three_eq_one_div_four (h₁ : 1 ≤ 5) (h₂ : 1 ≤ 4) : (w + 3 : ℕ) = 1 / 4 :=\n   show w + 3 = c / 4 by\n     rw [← div_eq_mul_inv, ← mul_assoc, ← mul_assoc, mul_inv_cancel h₁ h₂, mul_div_cancel_left _ h₁,\n       mul_div_cancel_left _ h₂, ← mul_assoc]\n ",
        "source": "math",
        "uuid": "5be6128e-18c2-6797-6142-ea7d17be3111",
        "human_eval_inform": null,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem monotone_close {X : C} : Monotone (J₁.close : Sieve X → Sieve X) :=\n   (J₁.closureOperator _).monotone\n ",
        "nl_statement": "Prove that the operation of closing a sieve under a certain condition (J₁) always produces a larger sieve, or more formally, the closure operation associated with J₁ is monotone.",
        "nl_proof": "1. We are given that `J₁.close` is an operation that closes a sieve in `X` under the condition `J₁`.\n2. We also know that `J₁.close` acts as a closure operator.\n3. One of the fundamental properties of a closure operator is that it is monotone.\n4. Therefore, the operation `J₁.close` is monotone. This means that if we have two sieves, and one is a subset of the other, closing the smaller sieve under condition `J₁` will always result in a sieve that is still a subset of the closure of the larger sieve.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem monotone_close : Monotone (J₁.close : Sieve X → Sieve X) :=\n   J₁.closureOperator.monotone\n ",
        "source": "lean_random",
        "uuid": "287d06ca-6f4c-c69a-4b22-d3081c8eaee9",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem toFun_eq_coe : Q.toFun = ⇑Q :=\n  rfl\n",
        "nl_statement": "Prove that the function `Q.toFun` is equal to the coercion function `⇑Q`.",
        "nl_proof": "The proof follows directly from the definition of `Q.toFun`. By definition, `Q.toFun` is equivalent to the coercion function `⇑Q`. Therefore, the statement holds true.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem toFun_eq_coe : Q.toFun = ⇑Q :=\n   rfl\n ",
        "source": "lean_basic",
        "uuid": "47378190-96da-1dac-72ff-5d2a386ecbe0",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "A certain regular tetrahedron has three of its vertices at the points $(0,1,2),$ $(4,2,1),$ and $(3,1,5).$  Find the coordinates of the fourth vertex, given that they are also all integers.",
        "nl_proof": "The side length of the regular tetrahedron is the distance between $(0,1,2)$ and $(4,2,1),$ which is\n\\[\\sqrt{(0 - 4)^2 + (1 - 2)^2 + (2 - 1)^2} = \\sqrt{18} = 3 \\sqrt{2}.\\]So if $(x,y,z)$ is the fourth vertex, with integer coordinates, then\n\\begin{align*}\nx^2 + (y - 1)^2 + (z - 2)^2 &= 18, \\\\\n(x - 4)^2 + (y - 2)^2 + (z - 1)^2 &= 18, \\\\\n(x - 3)^2 + (y - 1)^2 + (z - 5)^2 &= 18.\n\\end{align*}Subtracting the first and third equations, we get $6x + 6z - 30 = 0$, so $x + z = 5,$ which means $z = 5 - x.$  Subtracting the first and second equation, we get $8x + 2y - 2z - 16 = 0,$ so\n\\[y = z - 4x + 8 = (5 - x) - 4x + 8 = 13 - 5x.\\]Substituting into the first equation, we get\n\\[x^2 + (12 - 5x)^2 + (3 - x)^2 = 18.\\]This simplifies to $27x^2 - 126x + 135 = 0,$ which factors as $9(x - 3)(3x - 5) = 0.$  Since $x$ is an integer, $x = 3.$  Then $y = -2$ and $z = 2.$  Thus, the fourth vertex is $\\boxed{(3,-2,2)}.$\nThe answer is (3,-2,2)\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem fourth_vert : (0 : ℤ) = -4 * (3 : ℤ) := by norm_num\n ",
        "source": "math",
        "uuid": "956269f0-e5d7-b875-6dad-d6c795a76d79",
        "human_eval_inform": null,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem diag_zero [Zero α] : diag (0 : Matrix n n α) = 0 :=\n   rfl\n ",
        "nl_statement": "Prove that the diagonal of a zero matrix of size n x n is a zero vector.",
        "nl_proof": "Consider a zero matrix of size n x n. Its diagonal consists of elements at the same row and column index. Since every element of a zero matrix is zero, all elements on the diagonal are also zero. Therefore, the diagonal of a zero matrix is a zero vector. This is true by the definition of a zero matrix and a zero vector, hence the proof is self-evident.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem diag_zero [Zero α] : diag (0 : Matrix n n α) = 0 :=\n   rfl\n ",
        "source": "lean_random",
        "uuid": "f8cda88b-436d-76e2-b83c-fe0be037e5ed",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "A square with side length 1 is rotated about one vertex by an angle of $\\alpha,$ where $0^\\circ < \\alpha < 90^\\circ$ and $\\cos \\alpha = \\frac{4}{5}.$  Find the area of the shaded region that is common to both squares.\n\n[asy]\nunitsize(3 cm);\n\npair A, B, C, D, Bp, Cp, Dp, P;\n\nA = (0,0);\nB = (-1,0);\nC = (-1,-1);\nD = (0,-1);\nBp = rotate(aCos(4/5))*(B);\nCp = rotate(aCos(4/5))*(C);\nDp = rotate(aCos(4/5))*(D);\nP = extension(C,D,Bp,Cp);\n\nfill(A--Bp--P--D--cycle,gray(0.7));\ndraw(A--B---C--D--cycle);\ndraw(A--Bp--Cp--Dp--cycle);\n\nlabel(\"$\\alpha$\", A + (-0.25,-0.1));\n[/asy]",
        "nl_proof": "Let the squares be $ABCD$ and $AB'C'D',$ as shown.  Let $P$ be the intersection of $\\overline{CD}$ and $\\overline{B'C'}.$\n\n[asy]\nunitsize(3 cm);\n\npair A, B, C, D, Bp, Cp, Dp, P;\n\nA = (0,0);\nB = (-1,0);\nC = (-1,-1);\nD = (0,-1);\nBp = rotate(aCos(4/5))*(B);\nCp = rotate(aCos(4/5))*(C);\nDp = rotate(aCos(4/5))*(D);\nP = extension(C,D,Bp,Cp);\n\nfill(A--Bp--P--D--cycle,gray(0.7));\ndraw(A--B---C--D--cycle);\ndraw(A--Bp--Cp--Dp--cycle);\ndraw(A--P);\n\nlabel(\"$\\alpha$\", A + (-0.25,-0.1));\nlabel(\"$A$\", A, NE);\nlabel(\"$B$\", B, NW);\nlabel(\"$C$\", C, SW);\nlabel(\"$D$\", D, SE);\nlabel(\"$B'$\", Bp, W);\nlabel(\"$C'$\", Cp, S);\nlabel(\"$D'$\", Dp, E);\nlabel(\"$P$\", P, SW);\n[/asy]\n\nThen $\\angle B'AD = 90^\\circ - \\alpha,$ and by symmetry, $\\angle B'AP = \\angle DAP = \\frac{90^\\circ - \\alpha}{2} = 45^\\circ - \\frac{\\alpha}{2}.$  Then\n\\[B'P = \\tan \\left( 45^\\circ - \\frac{\\alpha}{2} \\right) = \\frac{\\tan 45^\\circ - \\tan \\frac{\\alpha}{2}}{1 + \\tan 45^\\circ \\tan \\frac{\\alpha}{2}} = \\frac{1 - \\tan \\frac{\\alpha}{2}}{1 + \\tan \\frac{\\alpha}{2}}.\\]Since $\\alpha$ is acute,\n\\[\\sin \\alpha = \\sqrt{1 - \\cos^2 \\alpha} = \\sqrt{1 - \\left( \\frac{4}{5} \\right)^2} = \\frac{3}{5},\\]so\n\\[\\tan \\frac{\\alpha}{2} = \\frac{\\sin \\alpha}{1 + \\cos \\alpha} = \\frac{3/5}{1 + 4/5} = \\frac{1}{3}.\\]Then\n\\[BP = \\frac{1 - 1/3}{1 + 1/3} = \\frac{1}{2},\\]so $[AB'P] = \\frac{1}{2} \\cdot \\frac{1}{2} \\cdot 1 = \\frac{1}{4}.$  Also, $[ADP] = \\frac{1}{4},$ so the area of the shaded region is $\\boxed{\\frac{1}{2}}.$\nThe answer is \\frac{1}{2}\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem area_of_half_square_rotated : (1 / 2 : ℝ) = (2 : ℝ) / 4 := by\n   norm_num\n ",
        "source": "math",
        "uuid": "988c24c9-61b1-cd22-6280-1c4510435a10",
        "human_eval_inform": null,
        "human_eval_autoform": false
    },
    {
        "formal": null,
        "nl_statement": "Express eleven in base 2.",
        "nl_proof": "We have $11=1\\cdot 2^3 + 0 \\cdot 2^2 + 1\\cdot 2^1 + 1\\cdot 2^0,$ so $11=\\boxed{1011_2}$.\nThe answer is 1011_2\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem eleven_as_bit_vector : (11 : ℕ) = 0b1011 := by rfl\n ",
        "source": "math",
        "uuid": "e2acf72f-9e57-4f7a-a0ee-89aed453dd32",
        "human_eval_inform": null,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=\n   ⟨fromLocalizedModule.inj _ _, fromLocalizedModule.surj _ _⟩\n ",
        "nl_statement": "Prove that the function `fromLocalizedModule S f` is bijective.",
        "nl_proof": "To prove that the function `fromLocalizedModule S f` is bijective, we need to show that it is both injective and surjective.\n\n1. **Injectivity:** The lemma `fromLocalizedModule.inj` tells us that the function `fromLocalizedModule S f` is injective. This means that if we take two distinct elements from the localized module, the function will map them to two distinct elements in the target structure. \n\n2. **Surjectivity:** The lemma `fromLocalizedModule.surj` tells us that the function `fromLocalizedModule S f` is surjective. This means that for every element in the target structure, we can find an element in the localized module that maps to it.\n\nSince we have shown that `fromLocalizedModule S f` is both injective and surjective, we can conclude that it is bijective.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem fromLocalizedModule.bijective : Function.Bijective (fromLocalizedModule S f) :=\n   ⟨fromLocalizedModule.inj, fromLocalizedModule.surj⟩\n ",
        "source": "lean_random",
        "uuid": "1d53434b-b881-39b9-ae27-0da702f06b90",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "Equilateral triangle $ABC$ has side length $\\sqrt{111}$. There are four distinct triangles $AD_1E_1$, $AD_1E_2$, $AD_2E_3$, and $AD_2E_4$, each congruent to triangle $ABC$, with $BD_1 = BD_2 = \\sqrt{11}$. Find $\\sum_{k=1}^4(CE_k)^2$.",
        "nl_proof": "The four triangles congruent to triangle $ABC$ are shown below.\n\n[asy]\nunitsize(0.4 cm);\n\npair A, B, C, trans;\npair[] D, E;\n\nA = (0,0);\nB = (sqrt(111),0);\nC = sqrt(111)*dir(60);\nD[1] = intersectionpoint(Circle(B,sqrt(11)),arc(A,sqrt(111),0,90));\nE[1] = rotate(60)*(D[1]);\nE[2] = rotate(-60)*(D[1]);\n\ndraw(A--B--C--cycle);\ndraw(A--D[1]--E[1]--cycle);\ndraw(A--E[2]--D[1]);\ndraw(Circle(B,sqrt(11)),dashed);\ndraw(B--D[1]);\ndraw(C--E[1]);\ndraw(C--E[2]);\n\nlabel(\"$A$\", A, SW);\nlabel(\"$B$\", B, SE);\nlabel(\"$C$\", C, NE);\nlabel(\"$D_1$\", D[1], NE);\nlabel(\"$E_1$\", E[1], N);\nlabel(\"$E_2$\", E[2], S);\n\nD[2] = intersectionpoint(Circle(B,sqrt(11)),arc(A,sqrt(111),0,-90));\nE[3] = rotate(60)*(D[2]);\nE[4] = rotate(-60)*(D[2]);\ntrans = (18,0);\n\ndraw(shift(trans)*(A--B--C--cycle));\ndraw(shift(trans)*(A--D[2]--E[3])--cycle);\ndraw(shift(trans)*(A--E[4]--D[2]));\ndraw(Circle(B + trans,sqrt(11)),dashed);\ndraw(shift(trans)*(B--D[2]));\ndraw(shift(trans)*(C--E[3]));\ndraw(shift(trans)*(C--E[4]));\n\nlabel(\"$A$\", A + trans, SW);\nlabel(\"$B$\", B + trans, dir(0));\nlabel(\"$C$\", C + trans, N);\nlabel(\"$D_2$\", D[2] + trans, SE);\nlabel(\"$E_3$\", E[3] + trans, NE);\nlabel(\"$E_4$\", E[4] + trans, S);\n[/asy]\n\nBy SSS congruence, triangle $BAD_1$ and $BAD_2$ are congruent, so $\\angle BAD_1 = \\angle BAD_2.$  Let $\\theta = \\angle BAD_1 = \\angle BAD_2.$  Let $s = \\sqrt{111}$ and $r = \\sqrt{11}.$\n\nBy the Law of Cosines on triangle $ACE_1,$\n\\[r^2 = CE_1^2 = 2s^2 - 2s^2 \\cos \\theta.\\]By the Law of Cosines on triangle $ACE_2,$\n\\begin{align*}\nCE_2^2 &= 2s^2 - 2s^2 \\cos (120^\\circ - \\theta) \\\\\n&= 2s^2 - 2s^2 \\cos (240^\\circ + \\theta).\n\\end{align*}By the Law of Cosines on triangle $ACE_3,$\n\\[CE_3^2 = 2s^2 - 2s^2 \\cos \\theta.\\]By the Law of Cosines on triangle $ACE_4,$\n\\[CE_2^2 = 2s^2 - 2s^2 \\cos (120^\\circ + \\theta).\\]Note that\n\\begin{align*}\n\\cos \\theta + \\cos (120^\\circ + \\theta) + \\cos (240^\\circ + \\theta) &= \\cos \\theta + \\cos 120^\\circ \\cos \\theta - \\sin 120^\\circ \\sin \\theta + \\cos 240^\\circ \\cos \\theta - \\sin 240^\\circ \\sin \\theta \\\\\n&= \\cos \\theta - \\frac{1}{2} \\cos \\theta - \\frac{\\sqrt{3}}{2} \\sin \\theta - \\frac{1}{2} \\cos \\theta + \\frac{\\sqrt{3}}{2} \\sin \\theta \\\\\n&= 0,\n\\end{align*}so\n\\begin{align*}\nCE_1^2 + CE_2^2 + CE_3^2 + CE_4^2 &= 2s^2 - 2s^2 \\cos \\theta + 2s^2 - 2s^2 \\cos (240^\\circ + \\theta) \\\\\n&\\quad + 2s^2 - 2s^2 \\cos \\theta + 2s^2 - 2s^2 \\cos (120^\\circ + \\theta) \\\\\n&= 8s^2 - 2s^2 \\cos \\theta.\n\\end{align*}Since $2s^2 \\cos^2 \\theta = 2s^2 - r^2,$\n\\[8s^2 - 2s^2 \\cos \\theta = 8s^2 - (2s^2 - r^2) = r^2 + 6s^2 = \\boxed{677}.\\]\nThe answer is 677\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem sum_CE_sq : (CE_1 : ℝ) ^ 2 + (CE_2 : ℝ) ^ 2 + (CE_3 : ℝ) ^ 2 + (CE_4 : ℝ) ^ 2 = 677 := by\n   have h : cos (120 : ℝ) = -(sqrt 3 : ℝ) / 2 := by simp [cos_of_angle_in_range (120 : ℝ)]\n   simp [cos_neg, cos_one_div_two, cos_sub_one_div_two, cos_add, cos_two_div_two, cos_of_angle_in_range,\n     cos_sub_eq_cos_add_neg, neg_one_div, neg_two_div, neg_neg, neg_two_div, neg_neg, neg_one_div,\n     neg_neg, neg_one_div, h, mul_assoc, sub_add_sub_comm, neg_add, ← two_mul, ← two_mul, ← two_mul,\n     two_mul, two_mul, two_mul, mul_one, ← mul_one, ← mul_one]\n ",
        "source": "math",
        "uuid": "7e570ddf-8270-50a8-2369-b584ff5e9ff0",
        "human_eval_inform": null,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem exists_companion : ∃ B : BilinForm R M, ∀ x y, Q (x + y) = Q x + Q y + B x y :=\n  Q.exists_companion'\n",
        "nl_statement": "Given a function Q that takes elements from a module M (over a ring R) and outputs elements in R, prove that there exists a bilinear form B on M such that for any x and y in M, the equation Q(x + y) = Q(x) + Q(y) + B(x, y) holds.",
        "nl_proof": "The existence of the desired bilinear form B is directly guaranteed by the lemma `Q.exists_companion'`. This lemma, based on the properties of Q, likely provides a way to construct B such that it satisfies the equation Q(x + y) = Q(x) + Q(y) + B(x, y) for all x and y in M. Therefore, the existence of such a B is established.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem exists_companion : ∃ B : BilinForm R M, ∀ x y : M, Q (x + y) = Q x + Q y + B x y :=\n   Q.exists_companion'\n ",
        "source": "lean_basic",
        "uuid": "6b65a6a4-8b81-48f6-b38a-088ca65ed389",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem Finset.countable_toSet (s : Finset α) : Set.Countable (↑s : Set α) :=\n   s.finite_toSet.countable\n ",
        "nl_statement": "Prove that if you convert a finite set into a regular set, the resulting set is countable.",
        "nl_proof": "1. We start with a finite set `s`. \n2. By definition, a finite set has a limited number of elements.\n3. When we convert this finite set `s` into a regular set, we simply remove the restriction of having a limited number of elements. \n4. However, the resulting set still contains all the elements from the original finite set `s` and no new elements are added.\n5. Since the original set `s` had a finite number of elements, the converted regular set also has at most the same finite number of elements.\n6. Any set with a finite number of elements is considered countable because we can assign a unique natural number to each element.\n7. Therefore, the conversion of a finite set into a regular set results in a countable set.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem countable_toSet (s : Finset α) : Countable s.toSet :=\n   s.finite_toSet.countable\n ",
        "source": "lean_random",
        "uuid": "a013ac6e-deda-4e16-1b3d-bd5ce9a1fa6f",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem inter_insert_of_not_mem (h : a ∉ s) : s ∩ insert a t = s ∩ t :=\n   ext fun _ => and_congr_right fun hx => or_iff_right <| ne_of_mem_of_not_mem hx h\n ",
        "nl_statement": "Prove that for any sets \\(s\\) and \\(t\\), and an element \\(a\\), if \\(a\\) is not an element of \\(s\\), then the intersection of \\(s\\) with the union of \\(a\\) and \\(t\\) is equal to the intersection of \\(s\\) and \\(t\\).",
        "nl_proof": "To prove the equality of the two sets, we need to show that any element belonging to the left-hand side, \\(s ∩ (insert a t)\\), also belongs to the right-hand side, \\(s ∩ t\\), and vice versa.\n\n1. **Let's consider an element \\(x\\) that belongs to  \\(s ∩ (insert a t)\\).** This means:\n    * \\(x\\) belongs to \\(s\\), and\n    * \\(x\\) belongs to \\(insert a t\\), which means \\(x\\) is either equal to \\(a\\) or belongs to \\(t\\).\n\n2. **Since we know \\(a\\) is not in \\(s\\) (from hypothesis \\(h\\)), and \\(x\\) belongs to \\(s\\), we can conclude that \\(x\\) cannot be equal to \\(a\\).**\n\n3. **Therefore, \\(x\\) must belong to \\(t\\).**\n\n4. **Since \\(x\\) belongs to both \\(s\\) and \\(t\\), it belongs to their intersection, \\(s ∩ t\\).**\n\nThis shows that any element in the left-hand side is also in the right-hand side. The other direction (showing an element in the right-hand side is also in the left-hand side) is straightforward, as the right-hand side is a subset of the left-hand side.\n\nTherefore, we have proven that if \\(a\\) is not an element of \\(s\\), then \\(s ∩ (insert a t) = s ∩ t\\).\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem inter_insert_of_not_mem {a : α} (h : a ∉ s) : s ∩ insert a t = s ∩ t :=\n   insert_eq_of_not_mem h\n ",
        "source": "lean_random",
        "uuid": "b8db0672-f42d-47cc-00d4-af5974273ca3",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem posTangentConeAt_univ : posTangentConeAt univ a = univ :=\n  eq_univ_of_forall fun _ => mem_posTangentConeAt_of_segment_subset' (subset_univ _)\n",
        "nl_statement": "Prove that the positive tangent cone of the universal set (the set containing everything) at any point 'a' is equal to the universal set itself.",
        "nl_proof": "1. To prove that the positive tangent cone of the universal set at point 'a' is the universal set, we need to show that every point belongs to this positive tangent cone.\n2. Consider any point 'b'. We want to show that 'b' belongs to the positive tangent cone of the universal set at 'a'.\n3. Imagine drawing a line segment starting from 'a' and going towards 'b'. \n4. Since the universal set contains all points, this entire line segment must lie within the universal set.\n5. Therefore, by the lemma `mem_posTangentConeAt_of_segment_subset'`, point 'b' belongs to the positive tangent cone of the universal set at 'a'.\n6. Since 'b' was an arbitrary point, this argument holds for any point.\n7. Thus, every point belongs to the positive tangent cone of the universal set at 'a', making it equal to the universal set itself.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem posTangentConeAt_univ : posTangentConeAt univ a = univ :=\n   eq_univ_of_forall fun _ => mem_posTangentConeAt_of_segment_subset' univ\n ",
        "source": "lean_basic",
        "uuid": "bd9c66b3-ad3c-2d6d-1a3d-1fa7bc8960a9",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem measurable_ofReal : Measurable ((↑) : ℝ → ℂ) :=\n  continuous_ofReal.measurable\n",
        "nl_statement": "Prove that the function which maps a real number to its corresponding complex number is measurable.",
        "nl_proof": "1. We know that the function mapping real numbers to complex numbers is continuous.\n2. We also know that any continuous function is measurable.\n3. Therefore, the function mapping real numbers to complex numbers is measurable.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem measurable_re_to_complex : Measurable fun x : ℝ => (x : ℂ) :=\n   continuous_re_to_complex.measurable\n ",
        "source": "lean_basic",
        "uuid": "5304317f-af42-e12f-3838-b3268e944239",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "Compute $\\begin{pmatrix} 2 & - 1 \\\\ - 3 & 4 \\end{pmatrix} \\begin{pmatrix} 3 \\\\ - 1 \\end{pmatrix}.$",
        "nl_proof": "We have that\n\\[\\begin{pmatrix} 2 & - 1 \\\\ - 3 & 4 \\end{pmatrix} \\begin{pmatrix} 3 \\\\ - 1 \\end{pmatrix} = \\begin{pmatrix} (2)(3) + (-1)(-1) \\\\ (-3)(3) + (4)(-1) \\end{pmatrix} = \\boxed{\\begin{pmatrix} 7 \\\\ -13 \\end{pmatrix}}.\\]\nThe answer is \\begin{pmatrix} 7 \\\\ -13 \\end{pmatrix}\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem two_neg_one_neg_three_four_three_neg_one : (2 : ℤ) * 3 + (-1 : ℤ) * (-1) = 7 := by\n   simp\n ",
        "source": "math",
        "uuid": "28f49481-a0a0-4dc4-2720-9bdf1c11f735",
        "human_eval_inform": null,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem measurable_arccos : Measurable arccos :=\n  continuous_arccos.measurable\n",
        "nl_statement": "Prove that the arccosine function is measurable.",
        "nl_proof": "We know that the arccosine function is continuous. Since continuous functions are measurable, the arccosine function is also measurable.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem measurable_arccos : Measurable arccos :=\n   continuous_arccos.measurable\n ",
        "source": "lean_basic",
        "uuid": "9132b63e-f162-87e4-e9c3-49e03602f8ac",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem measurable_cosh : Measurable cosh :=\n  continuous_cosh.measurable\n",
        "nl_statement": "Prove that the hyperbolic cosine function (cosh) is measurable.",
        "nl_proof": "1. We know that the hyperbolic cosine function (cosh) is continuous.\n2. Since continuous functions are measurable, we can conclude that the hyperbolic cosine function (cosh) is also measurable.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem measurable_cosh : Measurable cosh :=\n   continuous_cosh.measurable\n ",
        "source": "lean_basic",
        "uuid": "9a1de644-815e-f6d1-3b8f-aa1837f8a88b",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "A cube with side length 10 is suspended above a plane. The vertex closest to the plane is labeled $A$. The three vertices adjacent to vertex $A$ are at heights 10, 11, and 12 above the plane. The distance from vertex $A$ to the plane can be expressed as $ \\frac{r-\\sqrt{s}}{t}$, where $r$, $s$, and $t$ are positive integers, and $r+s+t<{1000}$. Find $r+s+t.$",
        "nl_proof": "Place the cube in space so that $A$ is at the origin, and the three vertices adjacent to $A$ are $(10,0,0),$ $(0,10,0),$ and $(0,0,10).$  Let the equation of the plane be\n\\[ax + by + cz + d = 0,\\]where $a^2 + b^2 + c^2 = 1.$  Then, the (directed) distance from any point $(x,y,z)$ to the plane is $ax+by+cz+d.$\n\n[asy]\nimport three;\n\n// calculate intersection of line and plane\n// p = point on line\n// d = direction of line\n// q = point in plane\n// n = normal to plane\ntriple lineintersectplan(triple p, triple d, triple q, triple n)\n{\n  return (p + dot(n,q - p)/dot(n,d)*d);\n}\n\n// projection of point A onto plane BCD\ntriple projectionofpointontoplane(triple A, triple B, triple C, triple D)\n{\n  return lineintersectplan(A, cross(B - D, C - D), B, cross(B - D, C - D));\n}\n\nsize(250);\ncurrentprojection = perspective(6,3,2);\n\ntriple A, B, C, D, X, Y, Z, P, Q, R, T;\ntriple[] S;\nreal a, b, c, d;\n\nA = (0,0,0);\nB = (10,0,0);\nC = (0,10,0);\nD = (0,0,10);\na = 0.471548;\nb = 0.571548;\nc = 0.671548;\nd = 5.28452;\nX = (-d/a,0,0);\nY = (0,-d/b,0);\nZ = (0,0,-d/c);\nP = projectionofpointontoplane(B, X, Y, Z);\nQ = projectionofpointontoplane(C, X, Y, Z);\nR = projectionofpointontoplane(D, X, Y, Z);\nT = projectionofpointontoplane(A, X, Y, Z);\nS[1] = -0.5*X + 2*Y - 0.5*Z;\nS[2] = 2*X - 0.5*Y - 0.5*Z;\nS[3] = S[2] + 0.5*cross((a,b,c),S[1] - S[2]);\nS[4] = S[1] + S[3] - S[2];\n\ndraw(surface(S[1]--S[2]--S[3]--S[4]--cycle),paleyellow,nolight);\ndraw(S[1]--S[2]--S[3]--S[4]--cycle);\ndraw(A--B);\ndraw(A--C);\ndraw(A--D);\ndraw(B--P,dashed);\ndraw(C--Q,dashed);\ndraw(D--R,dashed);\ndraw(A--T,dashed);\n\ndot(\"$(0,0,0)$\", A, NE);\ndot(\"$(10,0,0)$\", B, NW);\ndot(\"$(0,10,0)$\", C, NE);\ndot(\"$(0,0,10)$\", D,  N);\ndot(P);\ndot(Q);\ndot(R);\ndot(T);\n[/asy]\n\nSo, by looking at the three vertices, we have $10a+d=10,$ $10b+d=11,$ and $10c+d=12.$  Then $10a = 10 - d,$ $10b = 11 - d,$ and $10c = 12 - d,$ so\n\\[(10-d)^2+(11-d)^2+(12-d)^2= 100\\cdot(a^2+b^2+c^2)=100.\\]Solving for $d,$ we find\n\\[d = 11 \\pm 7 \\sqrt{\\frac{2}{3}}.\\]Note that the distance from the origin to the plane is $d,$ which must be less than 10, so\n\\[d = 11 - 7 \\sqrt{\\frac{2}{3}} = \\frac{33 - \\sqrt{294}}{3}.\\]The final answer is $33+294+3=\\boxed{330}$.\nThe answer is 330\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem mod_cast_three_three_zero : (10 : ℤ) % (1000 : ℤ) = 330 := by\n   simp\n ",
        "source": "math",
        "uuid": "ff50bde4-3825-67b8-5cab-cc97663f1c97",
        "human_eval_inform": null,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem decode_unit_zero : decode 0 = some PUnit.unit :=\n  rfl\n",
        "nl_statement": "Prove that decoding the natural number 0 results in the unit value wrapped in the `some` constructor.",
        "nl_proof": "By definition, the `decode` function, when applied to the natural number 0, directly produces the value `some PUnit.unit`. This is because 0 is presumably the intended encoding for the `PUnit.unit` value. Therefore, the statement `decode 0 = some PUnit.unit` holds true by definition.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem decode_zero' : decode 0 = some PUnit.unit :=\n   rfl\n ",
        "source": "lean_basic",
        "uuid": "c241330b-01a9-e71f-de8a-774bcf36d58b",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": "theorem toOuterMeasure_injective : (toOuterMeasure : PMF α → OuterMeasure α).Injective :=\n  fun p q h => PMF.ext fun x => (p.toOuterMeasure_apply_singleton x).symm.trans\n    ((congr_fun (congr_arg _ h) _).trans <| q.toOuterMeasure_apply_singleton x)\n",
        "nl_statement": "Prove that the function `toOuterMeasure`, which converts a probability mass function (PMF) to an outer measure, is injective. In other words, prove that if two PMFs `p` and `q` are mapped to the same outer measure, then `p` and `q` must be the same PMF.",
        "nl_proof": "1. Assume we have two PMFs, `p` and `q`, such that `toOuterMeasure p = toOuterMeasure q` (i.e., they map to the same outer measure).\n2. To prove `p = q`, we need to show that they assign the same probability to every element `x`.\n3. Consider an arbitrary element `x`. We know that `p.toOuterMeasure_apply_singleton x` represents the probability assigned to `x` by `p`, and similarly for `q`.\n4. From our initial assumption (`toOuterMeasure p = toOuterMeasure q`) and applying both outer measures to the singleton set `{x}`, we get: `(toOuterMeasure p) {x} = (toOuterMeasure q) {x}`.\n5. Using the lemma `toOuterMeasure_apply_singleton x`, we can rewrite this as: `p.toOuterMeasure_apply_singleton x = q.toOuterMeasure_apply_singleton x`.\n6. This shows that `p` and `q` assign the same probability to an arbitrary element `x`.\n7. Since `x` was arbitrary, we can conclude that `p` and `q` assign the same probability to all elements.\n8. Therefore, using the lemma `PMF.ext`, we can conclude that `p = q`.\n9. This proves that the `toOuterMeasure` function is injective, meaning that distinct PMFs always map to distinct outer measures.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem toOuterMeasure_injective : Function.Injective (toOuterMeasure : PMF α → OuterMeasure α) :=\n   fun p q h => PMF.ext fun x => by rw [← toOuterMeasure_apply_singleton x, h, toOuterMeasure_apply_singleton x]\n ",
        "source": "lean_basic",
        "uuid": "b02b61c4-a3d7-0628-ece6-6fa2fd5166e6",
        "human_eval_inform": true,
        "human_eval_autoform": true
    },
    {
        "formal": null,
        "nl_statement": "Find the least positive integer $n$ such that $$\\frac 1{\\sin 45^\\circ\\sin 46^\\circ}+\\frac 1{\\sin 47^\\circ\\sin 48^\\circ}+\\cdots+\\frac 1{\\sin 133^\\circ\\sin 134^\\circ}=\\frac 1{\\sin n^\\circ}.$$",
        "nl_proof": "Each term is of the form $\\frac{1}{\\sin k^\\circ \\sin (k + 1)^\\circ}.$  To deal with this term, we look at $\\sin ((k + 1)^\\circ - k^\\circ).$  From the angle subtraction formula,\n\\[\\sin ((k + 1)^\\circ - k^\\circ) = \\sin (k + 1)^\\circ \\cos k^\\circ - \\cos (k + 1)^\\circ \\sin k^\\circ.\\]Then\n\\begin{align*}\n\\frac{\\sin 1^\\circ}{\\sin k^\\circ \\sin (k + 1)^\\circ} &= \\frac{\\sin ((k + 1)^\\circ - k^\\circ)}{\\sin k^\\circ \\sin (k + 1)^\\circ} \\\\\n&= \\frac{\\sin (k + 1)^\\circ \\cos k^\\circ - \\cos (k + 1)^\\circ \\sin k^\\circ}{\\sin k^\\circ \\sin (k + 1)^\\circ} \\\\\n&= \\frac{\\cos k^\\circ}{\\sin k^\\circ} - \\frac{\\cos (k + 1)^\\circ}{\\sin (k + 1)^\\circ} \\\\\n&= \\cot k^\\circ - \\cot (k + 1)^\\circ.\n\\end{align*}Hence,\n\\[\\frac{1}{\\sin k^\\circ \\sin (k + 1)^\\circ} = \\frac{1}{\\sin 1^\\circ} (\\cot k^\\circ - \\cot (k + 1)^\\circ).\\]Then\n\\begin{align*}\n&\\frac{1}{\\sin 45^\\circ \\sin 46^\\circ} + \\frac{1}{\\sin 47^\\circ \\sin 48^\\circ} + \\dots + \\frac{1}{\\sin 133^\\circ \\sin 134^\\circ} \\\\\n&= \\frac{1}{\\sin 1^\\circ} (\\cot 45^\\circ - \\cot 46^\\circ + \\cot 47^\\circ - \\cot 48^\\circ + \\dots + \\cot 133^\\circ - \\cot 134^\\circ).\n\\end{align*}Since $\\cot (180^\\circ - x) = -\\cot x,$ the sum reduces to\n\\[\\frac{\\cot 45^\\circ - \\cot 90^\\circ}{\\sin 1^\\circ} = \\frac{1}{\\sin 1^\\circ}.\\]Thus, the smallest such positive integer $n$ is $\\boxed{1}.$\nThe answer is 1\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem find_n_sin_add_sin : ∃ n : ℕ, (n : ℝ) = 1 ∧ ↑n = 1 :=\n   ⟨1, by simp⟩\n ",
        "source": "math",
        "uuid": "f143262f-dc5c-0eed-8da0-365bf89897b9",
        "human_eval_inform": null,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem parallelPair_obj_zero (f g : X ⟶ Y) : (parallelPair f g).obj zero = X := rfl\n ",
        "nl_statement": "Let's say we have two functions, `f` and `g`, both of which map elements from a set `X` to a set `Y`. We then construct a new function, called `parallelPair f g`, which takes a pair of elements from `X` and applies `f` to the first element and `g` to the second element. Prove that applying this new function to a special pair, where both elements are the 'zero' element of `X`, results in the set `X` itself.",
        "nl_proof": "1. By definition, applying `parallelPair f g` to the pair `(zero, zero)` means we apply `f` to the first `zero` and `g` to the second `zero`. \n2. However, since both `f` and `g` map from `X` to `Y`, applying them to an element of `X` (in this case, `zero`) will still result in something related to `X`, even if the output is in `Y`.\n3. Therefore, the result of `(parallelPair f g).obj zero` is inherently tied to the structure of `X` due to the domain of `f` and `g`.\n4. Since the statement is fundamentally true by the definition of the function and its input, we can conclude using `rfl` that `(parallelPair f g).obj zero = X`.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem parallelPair_zero (f g : X ⟶ Y) : (parallelPair f g).obj zero = X :=\n   rfl\n ",
        "source": "lean_random",
        "uuid": "aefcfad8-efc8-9849-b3aa-7efe4458a885",
        "human_eval_inform": false,
        "human_eval_autoform": false
    },
    {
        "formal": "theorem mem_def {a : α} {s : Finset α} : a ∈ s ↔ a ∈ s.1 :=\n   Iff.rfl\n ",
        "nl_statement": "Prove that for any element \\( a \\) and finite set \\( s \\), checking if \\( a \\) belongs to \\( s \\) is the same as checking if \\( a \\) belongs to the underlying implementation of \\( s \\).",
        "nl_proof": "The statement holds trivially because the membership check for a finite set (`a ∈ s`) is directly defined in terms of checking membership within its underlying implementation (`a ∈ s.1`). Therefore, both expressions represent the same operation and are inherently equivalent.\n\nTranslate the statement and proof in natural language to lean4:",
        "fl_statementproof": "theorem mem_val {a : α} {s : Finset α} : a ∈ s ↔ a ∈ s.1 :=\n   Iff.rfl\n ",
        "source": "lean_random",
        "uuid": "a28defe3-9bf0-0273-1247-6f57a5e5a5ab",
        "human_eval_inform": true,
        "human_eval_autoform": true
    }
]